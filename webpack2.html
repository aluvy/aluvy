<h3 data-ke-size="size23"><b>6-2. DefinePlugin</b></h3>
<p data-ke-size="size16">어플리케이션은 개발환경과 운영환경으로 나눠서 운영한다. 가령 환경에 따라 API 서버 주소가 다를 수 있다. 같은 소스 코드를 두 환경에 배포하기 위해서는 이러한 환경 의존적인 정보를 소스가 아닌 곳에서 관리하는 것이 좋다. 배포할 때마다 코드를 수정하는 것은 곤란하기 때문이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">웹팩인 이러한 환경 정보를 제공하기 위해 <span style="color: #000000;"><u>DefinePlugin</u></span> 을 제공한다.</p>
<p data-ke-size="size16">내장 플러그인으로 따로 설치 할 필요가 없다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>webpack.config.js:</b></p>
<pre id="code_1704846485506" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>const webpack = require('webpack');
// ...
plugins: [
 new webpack.DefinePlugin({})
]</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">빈 객체를 전달해도 기본적으로 넣어주는 값이 있다. 노드 환경 정보인 <span style="background-color: #dddddd;">process.env.NODE_ENV</span> 인데 웹팩 설정의 mode에 설정한 값이 여기에 들어간다.</p>
<p data-ke-size="size16">"development"를 설정했기 때문에 어플리케이션 코드에서 <span style="background-color: #dddddd;">process.env.NODE_ENV</span> 변수로 접근하면 "development" 값을 얻을 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>app.js:</b></p>
<pre id="code_1704846575392" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>console.log(process.env.NODE_ENV);	// "development"</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이 외에도 웹팩 컴파일 시간에 결정되는 값을 전역 상수 문자열로 어플리케이션에 주입할 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>webpack.config.js:</b></p>
<pre id="code_1704846632255" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>const webpack = require('webpack');
// ...
plugins: [
 new webpack.DefinePlugin({
  TWO: '1+1'
  'api.domain': JSON.stringify('http://dev.api.domain.com')
 })
]</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">TWO 라는 전역 변수에 1+1 이란 코드 조각을 넣었다. 실제 어플리케이션에서 이것을 출력해보면 2가 나올 것이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>app.js:</b></p>
<pre id="code_1704846662445" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>console.log(TWO);	// 2</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">코드가 아닌 값을 입력하려면 문자열화 한 뒤 넘긴다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>webpack.config.js:</b></p>
<pre id="code_1704846738173" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>const webpack = require('webpack');
// ...
plugins: [
 new webpack.DefinePlugin({
  VERSION: JSON.stringify("v1.2.3"),
  PRODUCTION: JSON.stringify(false),
  MAX_COUNT: JSON. stringify(999),
  "api.domain": JSON.stringify("http://dev.api.domain.com"),
 })
]</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>app.js:</b></p>
<pre id="code_1704846799120" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>console.log(VERSION);	// 'v.1.2.3'
console.log(PRODUCTION);	// true
console.log(MAX_COUNT);	// 999
console.log(api.domain);	// 'http://dev.api.domain.com'</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">빌드 타임에 결정된 값을 어플리케이션에 전달할 때는 이 플러그인을 사용하자.</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><b>6-3. HtmlWebpackPlugin</b></h3>
<p data-ke-size="size16">이번엔 써드 파티 패키지에 대해 알아보자. <span style="color: #000000;"><u>HtmlWebpackPlugin</u></span> 은 HTML 파일을 후처리하는데 사용한다. 빌드 타임의 값을 넣거나 코드를 압축할 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">먼저 패키지를 다운로드 한다.</p>
<pre id="code_1704847189199" class="shell" data-ke-language="shell" data-ke-type="codeblock"><code>$ npm install html-webpack-plugin@3</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이 플러그인으로 빌드하면 HTML 파일이 아웃풋에 생성될 것이다. index.html 파일을 src/index.html 로 옮긴 뒤 다음과 같이 작성해보자.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>src/index.html:</b></p>
<pre id="code_1704847278622" class="html xml" data-ke-language="html" data-ke-type="codeblock"><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;타이틀&lt;%= env %&gt;&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- 로딩 스크립트 제거 --&gt;
    &lt;!-- &lt;script src="dist/main.js"&gt;&lt;/script&gt; --&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">타이틀 부분에 ejs 문법을 이용하는데 <span style="background-color: #dddddd;">&lt;%= env %&gt;</span> 는 전달받은 env 변수 값을 출력한다.</p>
<p data-ke-size="size16">HtmlWebpackPlugin은 이 변수에 데이터를 주입시켜 동적으로 HTML 코드를 생성한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">뿐만 아니라 웹팩으로 빌드한 결과물을 자동으로 로딩하는 코드를 주입해 준다. 때문에 스크립트 로딩 코드도 제거했다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>webpack.config.js:</b></p>
<pre id="code_1704847442163" class="shell" data-ke-language="shell" data-ke-type="codeblock"><code>const HtmlWebpackPlugin = require('html-webpack-plugin');
// ...
plugins: [
 new HtmlWebpackPlugin({
   template: './src/index.html',	// 템플릿 경로를 지정
   templateParameters: {	// 템플릿에 주입할 파라미터 변수 지정
     env: process.env.NODE === 'development' ? '(개발용)' : '',
   }
 })
]</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">환경 변수에 따라 타이틀명 뒤에 '(개발용)' 문자열을 붙이거나 떼거나 하도록 했다.</p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1704847484288" class="shell" data-ke-language="shell" data-ke-type="codeblock"><code>$ NODE_ENV=development npm run build</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">NODE_ENV=development 로 설정해서 빌드하면 빌드결과 "타이틀(개발용)" 으로 나온다.</p>
<p data-ke-size="size16">NODE_ENV=production 으로 설정해서 빌드하면 빌드결과 "타이틀" 로 나온다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">개발 환경과 달리 운영 환경에서는 파일을 압축하고 불필요한 주석을 제거하는 것이 좋다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>webpack.config.js:</b></p>
<pre id="code_1704847597383" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>const HtmlWebpackPlugin = require('html-webpack-plugin');
// ...
plugins: [
 new HtmlWebpackPlugin({
   template: './src/index.html',	// 템플릿 경로를 지정
   templateParameters: {	// 템플릿에 주입할 파라미터 변수 지정
     env: process.env.NODE === 'development' ? '(개발용)' : '',
   },
   minify: process.env.NODE_ENV === 'production' ? {
     collapseWhitespace: true,	// 빈칸 제거
     removeComments: true,	// 주석 제거
   } : false
 })
]</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">(문서에는 <a style="background-color: #ffffff; color: #000000; text-align: start;" href="https://github.com/jantimon/html-webpack-plugin/issues/1094"></a> minify 옵션이 웹팩 버전 3 기준으로 되어 있다)</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">환경 변수에 따라 minify 옵션을 켰다. <span style="background-color: #dddddd;">$ NODE_ENV=production npm run build</span> 로 빌드하면 아래처럼 코드가 압축된다. 물론 주석도 제거 되었다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">정적 파일을 배포하면 즉각 브라우저에 반영되지 않는 경우가 있다. 브라우저 캐쉬가 원인일 경우가 있는데 이를 위한 예방 옵션도 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>webpack.config.js:</b></p>
<pre id="code_1704847748413" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>new HtmlWebpackPlugin({
  hash: true,	// 정적 파일을 불러올 때 쿼리문자열에 웹팩 해쉬값을 추가한다.
})</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="background-color: #dddddd;">hash: true</span> 옵션을 추가하면 빌드할 시 생성하는 해쉬값을 정적파일 로딩 주소의 쿼리 문자열로 붙여서 HTML을 생성한다.</p>
<pre id="code_1704847812992" class="html xml" data-ke-language="html" data-ke-type="codeblock"><code>&lt;script type="text/javascript" src="main.js?808fae0ele8835f937b7&gt;&lt;/script&gt;</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><b>6-4. CleanWebpackPlugin</b></h3>
<p data-ke-size="size16"><span style="color: #000000;"><u>CleanWebpackPlugin</u></span> 은 빌드 이전 결과물을 제거하는 플러그인이다. 빌드 결과물은 아웃풋 경로에 모이는데 과거 파일이 남아있을 수 있다. 이전 빌드내용이 덮어씌워지면 상관없지만 그렇지 않으면 아웃풋 폴더에 여전히 남아있을 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">임시로 아웃풋 폴더에 foo.js 파일을 만든 후 다시 빌드해 보자... 파일이 남아있다.</p>
<p data-ke-size="size16">이러한 현상을 CleanWebpackPlugin 으로 해결해 보자. 먼저 패키지를 설치한다.</p>
<pre id="code_1704847901832" class="shell" data-ke-language="shell" data-ke-type="codeblock"><code>$ npm install clean-webpack-plugin@3</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">웹팩 설정을 추가한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>webpack.config.js:</b></p>
<pre id="code_1704847955028" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>const { CleanWebpackPlugin } = require('clean-webpack-plugin');
// ...
plugins: [
  new CleanWebpackPlugin()
]</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">빌드 결과 foo.js 가 깨끗히 사라졌다. 아웃풋 폴더인 dist 폴더가 모두 삭제된 후 결과물이 생성되었기 때문이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><b>6-5. MiniCssExtractPlugin</b></h3>
<p data-ke-size="size16">스타일시트가 점점 많아지면 하나의 자바스크립트 결과물로 만드는 것이 부담일 수 있다. 번들 결과에서 스타일시트 코드만 뽑아서 별도의 CSS 파일로 만들어 역할에 따라 파일을 분리하는 것이 좋다. 브라우저에서 큰 파일 하나를 내려받는 것 보다, 여러 개의 작은 파일을 동시에 다운로드 하는 것이 더 빠르다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">개발 환경에서는 CSS를 하나의 모듈로 처리해도 상관 없지만 프로덕션 환경에서는 분리하는 것이 효과적이다. <span style="color: #000000;"><u>MiniCssExtractPlugin</u></span> 은 CSS를 별도 파일로 뽑아내는 플러그인이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">먼저 패키지를 설치한다.</p>
<pre id="code_1704848073955" class="shell" data-ke-language="shell" data-ke-type="codeblock"><code>$ npm install mini-css-extract-plugin@0</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">웹팩 설정을 추가한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>webpack.config.js:</b></p>
<pre id="code_1704848162667" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>const MiniCssExtractPlugin = require('mini-css-extract-plugin');
// ...
plugins: [
  ...(process.env.NODE_ENV === 'production'
    ? [new MiniCssExtractPlugin({ filename: '[name].css' })]
    : []
]</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">프로덕션 환경일 경우만 이 플러그인을 추가했다. <span style="background-color: #dddddd;">filename</span> 에 설정한 값으로 아웃풋 경로에 CSS 파일이 생성될 것이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">개발 환경에서는 css-loader에 의해 자바스크립트 모듈로 변경된 스타일시트를 적용하기 위해 style-loader를 사용했다. 반면 프로덕션 환경에서는 별도의 CSS 파일로 추출하는 플러그인을 적용했으므로 다른 로더가 필요하다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>webpack.config.js:</b></p>
<pre id="code_1704848319146" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>const MiniCssExtractPlugin = require('mini-css-extract-plugin');
// ...
modules: {
  rules: [
    {
      test: /\.css$/,
      use: [
        process.env.NODE_ENV === 'production'
        ? MiniCssExtractPlugin.loader
        : 'style-loader',
        'css-loader'
      ]
    }
  ]
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">플러그인에서 제공하는 MiniCssExtractPlugin.loader 로더를 추가한다.</p>
<p data-ke-size="size16"><span style="background-color: #dddddd;">$ NODE_ENV=production npm run build</span> 로 결과를 확인해보자.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">dist/main.css 가 생성되었고 index.html 에 이 파일을 로딩하는 코드가 추가되었다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><b>7. 정리</b></h2>
<p data-ke-size="size16">ECMAScript2015 이전에는 모듈을 만들기 위해 즉시실행함수와 네임스페이스 패턴을 사용했다. 이후 각 커뮤니티에서 모듈 시스템 스펙이 나왔고 웹팩은 ECMAScript2015 모듈시스템을 쉽게 사용하도록 돕는 역할을 한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">엔트리 포인트를 시작으로 연결되어 있는 모든 모듈을 하나로 합쳐서 결과물을 만드는 것이 웹팩의 역할이다. 자바스크립트 모듈 뿐만 아니라 스타일시트, 이미지 파일까지도 모듈로 제공해 주기 때문에 일관적으로 개발할 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">웹팩의 로더와 플러그인의 원리에 대해 살펴보았고 자주 사용하는 것들의 기본적인 사용법에 대해 익혔다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size18"><b>김정환 블로그</b></p>
<p data-ke-size="size16">프론트엔드&nbsp;개발환경의&nbsp;이해:&nbsp;웹팩(기본)</p>
<p data-ke-size="size16"><a href="https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html" target="_blank" rel="noopener&nbsp;noreferrer">https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html</a></p>
<figure id="og_1704634827043" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="프론트엔드 개발환경의 이해: 웹팩(기본)" data-og-description="1. 배경 먼저 모듈에 대해 이야기 해보자. 문법 수준에서 모듈을 지원하기 시작한 것은 ES2015부터다. import/export 구문이 없었던 모듈 이전 상황을 살펴보는 것이 웹팩 등장 배경을 설명하는데 수월" data-og-host="jeonghwan-kim.github.io" data-og-source-url="https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html" data-og-url="https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html" data-og-image="https://scrap.kakaocdn.net/dn/JonkQ/hyUXVDnh7U/yd04K61SGYb1UI6tzhGAiK/img.jpg?width=200&amp;height=200&amp;face=0_0_200_200,https://scrap.kakaocdn.net/dn/cC3KcI/hyUXV4ryQy/wCi8xTLmHk2YNsA9qOnH41/img.png?width=768&amp;height=500&amp;face=0_0_768_500,https://scrap.kakaocdn.net/dn/cfT3q1/hyUXZFKHCF/QAd9RlNMtDZlIrEgqCrVBK/img.jpg?width=726&amp;height=291&amp;face=0_0_726_291"><a href="https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html" target="_blank" rel="noopener" data-source-url="https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/JonkQ/hyUXVDnh7U/yd04K61SGYb1UI6tzhGAiK/img.jpg?width=200&amp;height=200&amp;face=0_0_200_200,https://scrap.kakaocdn.net/dn/cC3KcI/hyUXV4ryQy/wCi8xTLmHk2YNsA9qOnH41/img.png?width=768&amp;height=500&amp;face=0_0_768_500,https://scrap.kakaocdn.net/dn/cfT3q1/hyUXZFKHCF/QAd9RlNMtDZlIrEgqCrVBK/img.jpg?width=726&amp;height=291&amp;face=0_0_726_291');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">프론트엔드 개발환경의 이해: 웹팩(기본)</p>
<p class="og-desc" data-ke-size="size16">1. 배경 먼저 모듈에 대해 이야기 해보자. 문법 수준에서 모듈을 지원하기 시작한 것은 ES2015부터다. import/export 구문이 없었던 모듈 이전 상황을 살펴보는 것이 웹팩 등장 배경을 설명하는데 수월</p>
<p class="og-host" data-ke-size="size16">jeonghwan-kim.github.io</p>
</div>
</a></figure>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
