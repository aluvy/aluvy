<h2 data-ke-size="size26"><span style="color: #000000;"><b>1. 배경</b></span></h2>
<p data-ke-size="size16">문법 수준에서 모듈을 지원하기 시작한 것은 ES2015부터다. import/export 구문이 없었던 모듈 이전 상황을 살펴보는 것이 웹팩 등장 배경을 설명하는데 수월할 것 같다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">아래 덧셈 함수를 보자.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>math.js:</b></p>
<pre id="code_1704761491126" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>function sum (a, b){
  return a + b
}	// 전역 공간에 sum이 노출</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>app.js:</b></p>
<pre id="code_1704761502224" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>sum(1, 2)	// 3</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">위 코드는 모두 하나의 HTML 파일 안에서 로딩해야만 실행된다.&nbsp; math.js가 로딩되면 app.js는 이름 공간에서 'sum'을 찾은 뒤 이 함수를 실행한다. 문제는 'sum'이 전역 공간에 노출된다는 것. 다른 파일에서도 'sum'이란 이름을 사용한다면 충돌한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><b>1-1. IIFE 방식의 모듈</b></h3>
<p data-ke-size="size16">이러한 문제를 예방하기 위해 스코프를 사용한다. 함수 스코프를 만들어 외부에서 안으로 접근하지 못하도록 공간을 격리하는 것이다. 스코프 안에서는 자신만의 이름 공간이 존재하므로 스코프 외부와 이름 충돌을 막을 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>math.js:</b></p>
<pre id="code_1704761692950" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>var math = math || {};	// math 네임스페이스, var로 선언해야 한다.

(function () {
  function sum(a, b){
    return a + b
  }
  
  math.sum = sum;	// 네임스페이스에 추가
})()</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">같은 코드를 즉시실행함수로 감쌌기 때문에 다른 파일에서 이 안으로 접근할 수가 없다. 심지어 같은 파일 일지라도 말이다. 자바스크립트 함수 스코프의 특징이다. 'sum'이란 이름은 즉시실행함수 안에 감추어졌기 때문에 외부에서는 같은 이름을 사용해도 괜찮다. 전역에 등록한 'math' 라는 이름 공간만 잘 활용하면 된다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><b>1-2. 다양한 모듈 스펙</b></h3>
<p data-ke-size="size16">이러한 방식으로 자바스크립트 모듈을 구현하는 대표적인 명세가 AMD와 CommonJS다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><u><span style="color: #000000;"><b>CommonJS</b></span></u>는 자바스크립트를 사용하는 모든 환경에서 모듈을 하는 것이 목표다. exports 키워드로 모듈을 만들고 require() 함수로 불러 들이는 방식이다. 대표적으로 서버 사이드 플랫폼인 Node.js에서 이를 사용한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>math.js:</b></p>
<pre id="code_1704761850323" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>exports function sum (a, b){
  return a + b;
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>app.js:</b></p>
<pre id="code_1704761870607" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>const math = require('./math.js')
math.sum(1, 2);	// 3</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #000000;"><u><b>AMD</b></u></span>&nbsp;(Asynchronous Module Definition)는 비동기로 로딩되는 환경에서 모듈을 사용하는 것이 목표다. 주로 브라우저 환경이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #000000;"><u><b>UMD</b></u></span> (Universal Module Definition)는 AMD 기반으로 CommonJS 방식까지 지원하는 통합 형태다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이렇게 각 커뮤니티에서 각자의 스펙을 제안하다가 <span style="color: #000000;"><u><b>ES2015에서 표준 모듈 시스템</b></u></span> 을 내 놓았다. 지금은 바벨과 웹팩을 이용해 모듈 시스템을 사용하는 것이 일반적이다. ES2015 모듈 시스템의 모습을 살펴보자.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>math.js:</b></p>
<pre id="code_1704762529567" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>export function sum (a, b) {
  return a + b
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>app.js:</b></p>
<pre id="code_1704762564639" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>import * as math from './math.js'
// import {sum} from './math.js'

math.sum(1, 2)	// 3</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="background-color: #dddddd;">export</span> 구문으로 모듈을 만들고 <span style="background-color: #dddddd;">import</span> 구문으로 가져올 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><b>1-3. 브라우저의 모듈 지원</b></h3>
<p data-ke-size="size16">안타깝게도 모든 브라우저에서 모듈 시스템을 지원하지는 않는다. 인터넷 익스플로러를 포함한 몇 몇 브라우저에서는 여전히 모듈을 사용하지 못한다. 가장 많이 사용하는 크롬 브라우저만 잠시 살펴보자. (<u>버전 61부터 모듈시스템을 지원</u> 한다)</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>index.html:</b></p>
<pre id="code_1704762728445" class="html xml" data-ke-language="html" data-ke-type="codeblock"><code>&lt;script type="module" src="app.js"&gt;&lt;/script&gt;</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="background-color: #dddddd;">&lt;script&gt;</span> 태그로 로딩할 때 <span style="background-color: #dddddd;">type="text/javascript"</span> 대신 <span style="background-color: #dddddd;">type="module"</span>을 사용한다. app.js는 모듈을 사용할 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">그러나 브라우저에 무관하게 모듈을 사용하고 싶은데.. 이제야 웹팩이 나올 차례다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><b>2. entry / output</b></h2>
<p data-ke-size="size16"><span style="color: #000000;"><b><u>웹팩</u></b></span>은 여러개 파일을 하나로 합쳐주는 번들러(bundler)다. 하나의 시작점(entry point)으로부터 의존적인 모듈을 전부 찾아내서 하나의 결과물을 만들어 낸다. app.js 부터 시작해 math.js 파일을 찾은 뒤 하나의 파을로 만드는 방식이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">간단히 웹팩으로 번들링 작업을 해보자.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">번들 작업을 하는 <span style="color: #000000;"><u>webpack</u></span> 패키지와 웹팩 터미널 도구인 <span style="color: #000000;"><u>webpack-cli</u></span> 를 설치한다.</p>
<pre id="code_1704762896489" class="shell" data-ke-language="shell" data-ke-type="codeblock"><code>$ npm install -D webpack@4 webpack-cli@3

// 설치 시 -D 옵션을 줬기 때문에 package.json 파일 내에 "DevDependencies"에서 설치된 "webpack"과 "webpack-cli"를 확인할 수 있다.
// 개발용 패키지라고 보면 된다.</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">설치 완료하면 <span style="background-color: #dddddd;">node_modules/.bin</span> 폴더에 실행 가능한 명령어가 몇 개 생긴다. webpack과 webpack-cli가 있는데 둘 중 하나를 실행하면 된다. <span style="background-color: #dddddd;">--help</span> 옵션으로 사용 방법을 확인해 보자.</p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1704763145535" class="shell" data-ke-language="shell" data-ke-type="codeblock"><code>$ node_modules/.bin/webpack --help

  --mode                 Enable production optimizations or development hints.
                                     [선택: "development", "production", "none"]
  --entry      The entry point(s) of the compilation.                   [문자열]
  --output, -o                  The output path and file for compilation assets</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="background-color: #dddddd;">--mode</span>, <span style="background-color: #dddddd;">--entry</span>, <span style="background-color: #dddddd;">--output</span> 세 개 옵션만 사용하면 코드를 묶을 수 있다.</p>
<pre id="code_1704763179636" class="shell" data-ke-language="shell" data-ke-type="codeblock"><code>$ node_modules/.bin/webpack --mode development --entry ./src/app.js --output dist/main.js</code></pre>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><span style="background-color: #dddddd;">--mode</span> 는 웹팩 실행 모드를 의미하는데 개발 버전인 development를 지정한다.</li>
<li><span style="background-color: #dddddd;">--entry</span> 는 시작점 경로를 지정하는 옵션이다.</li>
<li><span style="background-color: #dddddd;">--output</span> 은 번들링 결과물을 위치할 경로다.</li>
</ul>
<p data-ke-size="size16">위 명령어를 실행하면 dist/main.js에 번들된 결과가 저장된다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이 코드를 index.html 에 로딩하면 번들링 전과 똑같은 결과를 만든다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>index.html:</b></p>
<pre id="code_1704763286225" class="html xml" data-ke-language="html" data-ke-type="codeblock"><code>&lt;script src="dist/main.js"&gt;&lt;/script&gt;</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">옵션 중 <span style="background-color: #dddddd;">--config</span> 항목을 보자.</p>
<pre id="code_1704763312833" class="shell" data-ke-language="shell" data-ke-type="codeblock"><code>$ node_modules/.bin/webpack --help

  --config               Path to the config file
                         [문자열] [기본: webpack.config.js or webpackfile.js]</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이 옵션은 웹팩 설정파일의 경로를 지정할 수 있는데 기본 파일명이 webpack.config.js 혹은 webpackfile.js 다. <span style="background-color: #dddddd;">webpack.config.js</span> 파일을 만들어 방금 터미널에서 사용한 옵션을 코드로 구성해 보자.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>webpack.config.js:</b></p>
<pre id="code_1704763417652" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>const path = require("path")

module.exports = {
  mode: "development",
  entry: {
    main: "./src/app.js",
  },
  output: {
    filename: "[name].js",
    path: path.resolve("./dist")
  }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">터미널에서 사용한 옵션인 mode, entry, output 을 설정한다.</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><span style="background-color: #dddddd;">mode</span> 는 'development' 문자열을 사용했다.</li>
<li><span style="background-color: #dddddd;">entry</span> 는 어플리케이션 진입점인 src/app/js로 설정한다.</li>
<li><span style="background-color: #dddddd;">output</span> 에 설정한 '[name]'은 entry에 추가한 main이 문자열로 들어오는 방식이다.<br />output.path는 절대 경로를 사용하기 때문에 path 모듈의 resolve() 함수를 사용해서 계산했다. (path는 노드 코어 모듈 중 하나로 경로를 처리하는 기능을 제공한다)</li>
</ul>
<p data-ke-size="size16">웹팩 실행을 위한 NPM 커스텀 명령어를 추가한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>package.json:</b></p>
<pre id="code_1704763579697" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>{
  "scripts": {
    "build": "./mode_moduls/.bin/webpack"
  }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">모든 옵션을 웹팩 설정 파일로 옮겼기 때문에 단순히 <span style="background-color: #dddddd;">"webpack"</span> 명령어만 실행해도 된다. 이제부터는 <span style="background-color: #dddddd;">npm run build</span> 로 웹팩 작업을 지시할 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><span style="color: #000000;"><b>3. 로더</b></span></h2>
<h3 data-ke-size="size23"><b>3-1. 로더의 역할</b></h3>
<p data-ke-size="size16">웹팩은 모든 파일을 모듈로 바라본다. 자바스크립트로 만든 모듈 뿐만아니라 스타일시트, 이미지, 폰트까지도 전부 모듈로 보기 때문에 import 구문을 사용하면 자바스크립트 코드 안으로 가져올 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이것이 가능한 이유는 웹팩의 <span style="color: #000000;"><u><b>로더</b></u></span> 덕분이다. 로더는 타입스크립트 같은 다른 언어를 자바 스크립트 문법으로 변환해 주거나 이미지를 data URL 형식의 문자열로 변환한다. 뿐만아니라 CSS 파일을 자바스크립트에서 직접 로딩할 수 있도록 해준다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><b>3-2. 커스텀 로더 만들기</b></h3>
<p data-ke-size="size16">로더를 시작하기 전에 동작 원리를 이해하기 위해 로더를 직접 만들어 보자.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>myloader.js:</b></p>
<pre id="code_1704763811735" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>module.exports = function myloader (content) {
  console.log('myloader가 동작함');
  return content
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">함수로 만들 수 있는데 로더가 읽은 파일의 내용이 함수 인자 content로 전달된다. 로더가 동작하는지 확인하는 용도로 로그만 찍고 곧장 content를 돌려 준다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">로더를 사용하려면 웹팩 설정파일의 <span style="background-color: #dddddd;">module</span> 객체에 추가한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>webpack.config.js:</b></p>
<pre id="code_1704763915313" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>module: {
  rules: [{
    test: /\.js$/,	// .js 확장자로 끝나는 모든 파일
    use: [ path.resolve('./myloader.js') ]	// 방금 만든 로더를 적용한다.
  }]
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="background-color: #dddddd;">module.rules</span> 배열에 모듈을 추가하는데 test와 use로 구성된 객체를 전달한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="background-color: #dddddd;">test</span> 에는 로딩에 적용할 파일을 지정한다. 파일명 뿐만 아니라 파일 패턴을 정규표현식으로 지정할 수 있는데 위 코드는 .js 확장자를 갖는 모든 파일을 처리하겠다는 의미다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="background-color: #dddddd;">use</span> 에는 이 패턴에 해당하는 파일에 적용할 로더를 설정하는 부분이다. 방금 만든 myloader 함수의 경로를 지정한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이제 <span style="background-color: #dddddd;">npm run build</span> 로 웹팩을 실행해 보자.</p>
<pre id="code_1704764207448" class="shell" data-ke-language="shell" data-ke-type="codeblock"><code>$ npm run build

&gt; tmp@1.0.0 build /Users/kimjungwhan/tmp
&gt; webpack

myloader가 동작함
myloader가 동작함
Hash: 4a20077ca9bc74bc8ae2
Version: webpack 4.41.2
Time: 72ms
Built at: 12/11/2019 7:40:48 AM
  Asset      Size  Chunks            Chunk Names
main.js    4.5KiB    main  [emitted] main
Entrypoint main = main.js
[./src/app.js] 69 bytes {main} [built]</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">터미널에 'myloader가 동작함' 문자열이 찍힌다. myloader() 함수가 동작한 것이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">빌드결과를 살펴보면 이전과 동일하다. 로더가 뭔가를 처리하기 위해서 간단한 변환 작업을 추가해 보자. 소스에 있는 모든 console.log() 함수를 alert() 함수로 변경하도록 말이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>myloader.js:</b></p>
<pre id="code_1704764302959" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>module.exports = function myloader (content) {
  console.log('myloader가 동작함')
  return content.replace('console.log(', 'alert(')	// console.log( --&gt; alert( 로 치환
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">빌드 후 확인하면 다음과 같이 console.log() 함수가 alert() 함수로 변경되었다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><span style="color: #000000;"><b>4. 자주 사용하는 로더</b></span></h2>
<p data-ke-size="size16">로더의 동작 원리를 살펴 보았으니 이번에는 몇몇 자주 사용하는 로더를 소개하겠다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><b>4-1. css-loader</b></h3>
<p data-ke-size="size16">웹팩은 모든 것을 모듈로 바라보기 때문에 자바스크립트 뿐만 아니라 스타일시트도 import 구문으로 불러올 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>app.js:</b></p>
<pre id="code_1704764402335" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>import './style.css'</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>style.css:</b></p>
<pre id="code_1704764422125" class="css" data-ke-language="css" data-ke-type="codeblock"><code>body { background-color: green }</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">CSS 파일을 자바스크립트에서 불러와 사용하려면 CSS를 모듈로 변환하는 작업이 필요하다. <span style="color: #000000;"><u><b>css-loader</b></u></span> 가 그러한 역할을 하는데 우리 코드에서 CSS 파일을 모듈처럼 불러와 사용할 수 있게끔 해준다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">먼저 로더를 설치하자.</p>
<pre id="code_1704764552483" class="shell" data-ke-language="shell" data-ke-type="codeblock"><code>$ npm install css-loader@3</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">웹팩 설정에 로더를 추가한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>webpack.config.js:</b></p>
<pre id="code_1704764631817" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>module.exports = {
  module: {
   rules: [
     {
       test: /\.css$/,	// .css 확장자로 끝나는 모든 파일
       use: ['css-loader'],	// css-loader를 적용한다
     }
   ]
  }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">웹팩은 엔트리 포인트부터 시작해서 모듈을 검색하다가 CSS 파일을 찾으면 css-loader로 처리할 것이다. use.loader에 로더 경로를 설정하는 대신 배열에 로더 이름을 문자열로 전달해도 된다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">빌드 한 결과 CSS 코드가 자바스크립트로 변환된 것을 확인할 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><b>4-2. style-loader</b></h3>
<p data-ke-size="size16">모듈로 변경된 스타일 시트는 돔(CSSOM)에 추가되어야만 브라우저가 해석할 수 있다. css-loader로 처리하면 자바스크립트 코드로만 변경되었을 뿐 돔에 적용되지 않았기 때문에 스타일이 적용되지 않았다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #000000;"><u><b>style-loader</b></u></span> 는 자바스크립트로 변경된 스타일을 동적으로 돔에 추가하는 로더이다. CSS를 번들링 하기 위해서는 css-loader와 style-loader를 함께 사용한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">먼저 style-loader를 다운로드 한다.</p>
<pre id="code_1704765445397" class="shell" data-ke-language="shell" data-ke-type="codeblock"><code>$ npm install style-loader@1</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">그리고 웹팩 설정에 로더를 추가한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>package.json:</b></p>
<pre id="code_1704765514402" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [ 'style-loader', 'css-loader' ]		// style-loader를 앞에 추가한다.
      }
    ]
  }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">배열로 설정하면 뒤에서부터 앞으로 순서대로 로더가 동작한다. 위 설정은 모든 .css 확장자로 끝나는 모듈을 읽어 들여 css-loader를 적용하고 그 다음 style-loader를 적용한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><span style="color: #000000;"><b>4-3. file-loader</b></span></h3>
<p data-ke-size="size16">CSS 뿐만 아니라 소스코드에서 사용하는 모든 파일을 모듈로 사용하게끔 할 수 있다. 파일을 모듈 형태로 지원하고 웹팩 아웃풋에 파일을 옮겨주는 것이 <span style="color: #000000;"><b><u>file-loader</u></b></span>가 하는 일이다. 가령 CSS에서 url() 함수에 이미지 파일 경로를 지정할 수 있는데 웹팩은 file-loader를 이용해서 이 파일을 처리한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>style.css:</b></p>
<pre id="code_1704765671028" class="css" data-ke-language="css" data-ke-type="codeblock"><code>body { background-image: url(bg.png) }</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">배경 이미지를 bg.png 파일로 지정했다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">웹팩은 엔트리 포인트인 app.js 가 로딩하는 style.css 파일을 읽을 것이다. 그리고 이 스타일 시트는 url() 함수로 bg.png를 사용하는데 이때 로더를 동작시킨다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>webpack.config.js:</b></p>
<pre id="code_1704765779399" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>module.exports = {
  module: {
    rules: [
      {
        test: /\.png$/,	// .png 확장자로 마치는 모든 파일
        loader: 'file-loader',	// 파일 로더를 적용한다.
      }
    ]
  }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">웹팩이 .png 파일을 발견하면 file-loader를 실행할 것이다. 로더가 동작하고 나면 아웃풋에 설정한 경로로 이미지 파일이 복사된다. 아래 그림처럼 파일명이 해쉬코드로 변경되었다. 캐쉬 갱신을 위한 처리로 보인다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">하지만 이대로 index.html 파일을 브라우저에 로딩하면 이미지를 제대로 로딩하지 못할 것이다. CSS를 로딩하면 background-image: url(bg.png) 코드에 의해 동일 폴더에서 이미지를 찾으려고 시도할 것이다. 그러나 웹팩으로 빌드한 이미지 파일은 output인 dist 폴더 아래로 이동했기 때문에 이미지 로딩에 실패할 것이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">file-loader 옵션을 조정해서 경로를 바로 잡아 주어야 한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>webpack.config.js:</b></p>
<pre id="code_1704765947568" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>module.exports = {
  module: {
    rules: [
      {
        test: /\.png$/,
        loader: 'file-loader',
        options: {
          publicPath: './dist/',	// prefix를 아웃풋 경로로 지정
          name: '[name].[ext]?[hash]',
        }
      }
    ]
  }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="background-color: #dddddd;">publicPath</span> 옵션은 file-loader 가 처리하는 파일을 모듈로 사용할 때 경로 앞에 추가되는 문자열이다. output에 설정한 'dist' 폴더에 이미지 파일을 옮길 것이므로 publicPath 값을 이것으로 지정했다. 파일을 사용하는 측에서는 'bg.png'를 'dist/bg.png'로 변경하여 사용할 것이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">또한 <span style="background-color: #dddddd;">name</span> 옵션을 사용했는데 이것은 로더가 파일을 아웃푹에 복사할 때 사용되는 파일 이름이다. 기본적으로 설정된 해쉬값을 쿼리스트링으로 옮겨서 'bg.png?6453a9c65953c5c28aa2130dd437bbde' 형식으로 파일을 요청하도록 변경했다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><span style="color: #000000;"><b>4-4. url-loader</b></span></h3>
<p data-ke-size="size16">사용하는 이미지 갯수가 많다면 네트웤 리소스를 사용하는 부담이 있고 사이트 성능에 영향을 줄 수도 있다. 만약 한 페이지에서 작은 이미지를 여러 개 사용한다면 <span style="color: #000000;"><u><b>Data URI Scheme</b></u></span> 을 이용하는 방법이 더 나은 경우도 있다. 이미지를 Base64로 인코딩하여 문자열 형태로 소스코드에 넣는 형식이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #000000;"><u>url-loader</u></span> 는 이러한 처리를 자동화 해준다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">먼저 로더를 설치한다.</p>
<pre id="code_1704769599714" class="shell" data-ke-language="shell" data-ke-type="codeblock"><code>$ npm install url-loader@3</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">그리고 웹팩 설정을 추가한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>webpack.config.js:</b></p>
<pre id="code_1704769699164" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>{
  test: /\.png$/,
  use: {
    loader: 'url-loader',	// url 로더를 설정한다.
    options: {
      publicPath: './dist/',	// file-loader와 동일
      name: '[name].[ext]?[hash]',	// file-loader와 동일
      limit: 5000,	// 5kb 미만 파일만 data url로 처리
    }
  }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">file-loader와 옵션 설정이 거의 비슷하고 마지만 <span style="background-color: #dddddd;">limit</span> 속성만 추가했다. 모듈로 사용한 파일 중 크기가 5kb 미만인 파일만&nbsp; url-loader 를 적용하는 설정이다. 만약 이보다 크면 file-loader가 처리하는데 옵션 중 <span style="color: #000000;"><u>fallback</u></span> 기본값이 file-loader 이기 때문이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">빌드 결과를 보면 small.png 파일이 문자열로 변경되어 있는 것을 확인 할 수 있다. 반면 5kb 이상인 bg.png는 여전히 파일로 존재한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">브라우저에서도 확인하면 스타일시트에 small.png 가 Data url 형태로 변환되어 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">아이콘처럼 용량이 작거나 사용 빈도가 높은 이미지는 파일을 그대로 사용하기 보다는 Data URI Scheme을 적용하기 위해 url-loader를 사용하면 좋겠다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><b>5. 플러그인</b></h2>
<h3 data-ke-size="size23"><b>5-1. 플러그인의 역할</b></h3>
<p data-ke-size="size16">웹팩에서 알아야 할 마지막 기본 개념이 플러그인이다. 로더가 파일 단위로 처리하는 반면 플러그인은 번들된 결과물을 처리한다. 번들된 자바스크립트를 난독화 한다거나 특정 텍스트를 추출하는 용도로 사용한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이것도 사용하기에 앞서 동작 원리를 이해하기 위한 플러그인을 직접 만들어 보자.</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><b>5-1. 커스텀 플러그인 만들기</b></h3>
<p data-ke-size="size16">웹팩 문서의 <span style="color: #000000;"><u>Writing a plugin</u></span> 을 보면 클래스로 플러그인을 정의 하도록 한다. <u>헬로월드 코드</u>를 가져다 그대로 실행 붙여보자.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>myplugin.js:</b></p>
<pre id="code_1704771399180" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>class myPlugin {
  apply (compiler) {
    compiler.hooks.done.tap("My Plugin", stats =&gt; {
      console.log("MyPlugin: done")
    }
  }
}

module.exports = myPlugin</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">로더와 다르게 플러그인은 클래스로 제작한다. apply 함수를 구현하면 되는데 이 코드에서는 인자로 받은 compiler 객체 안에 있는 tap() 함수를 사용하는 코드다. 플러그인 작업이 완료되는(done) 시점에 로그를 찍는 코드인 것 같다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">플러그인을 웹팩 설정에 추가한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>webpack.config.js</b></p>
<pre id="code_1704771477158" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>const MyPlugin = require("./myplugin")

module.exports = {
  plugins: [new MyPlugin()],
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">웹팩 설정 객체의&nbsp; <span style="background-color: #dddddd;">plugins</span> 배열에 설정한다. 클래스로 제공되는 플러그인의 생성자 함수를 실행해서 넘기는 방식이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">웹팩으로 빌드해보자.</p>
<pre id="code_1704846158818" class="shell" data-ke-language="shell" data-ke-type="codeblock"><code>$ npm run build

&gt; tmp@1.0.0 build /Users/kimjunghwan/tmp
&gt; webpack

MyPlugin: done
Hash: 0c58c268e5e60b654dd30
Version: webpack 4.41.2
Time: 266ms
Build at: 12/11/2019 8:20:57 AM</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">로그가 찍힌 것을 보니 플러그인이 동작했다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">그런데 파일이 여러 개인데 로그는 한 번만 찍혔다. 모듈이 파일 하나 혹은 여러 개에 대해 동작하는 반면 플러그인은 하나로 번들링된 결과물을 대상으로 동작 한다. 우리 예제에서는 main.js 로 결과물이 하나이기 때문에 플러그인이 한 번만 동작 한 것이라 추측할 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">그러면 어떻게 번들 결과에 접근할 수 있을까? 웹팩 내장 플러그인 <span style="color: #000000;"><u>BannerPlugin 코드</u></span>를 참고하자.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>myplugin.js:</b></p>
<pre id="code_1704771664761" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>class MyPlugin {
  apply(compiler){
    compiler.hooks.done.tap("My Plugin", stats =&gt; {
      console.log("MyPlugin: done")
    }
    
    // compiler.plugin() 함수로 후처리한다
    compiler.plugin("emit", (comilation, callback) =&gt; {
      const source = compilation.assets["main.js"].source()
      console.log(source)
      callback()
    }
  }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">compiler.plugin() 함수의 두 번째 인자 콜백함수는 emit 이벤트가 발생하면 실행되는 녀석인 모양이다. 번들된 결과가 compilation 객체에 들어 있는데 compilation.assets['main.js'].source() 함수로 접근할 수 있다. 실행하면 터미널에 번들링된 결과물을 확인할 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1704846268438" class="shell" data-ke-language="shell" data-ke-type="codeblock"><code>$ npm run build

&gt; tmp@1.0.0 build /Users/kimjunghwan/tmp
&gt; webpack

(node:53861) DeprecationWrarning: Tapable.plugin is deprecated. Use new API on `.hooks` instead
/*****/ (function(modules) { // webpackBootstrap
...</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이걸 이용해서 번들 결과 상단에 아래와 같은 배너를 추가하는 플러그인으로 만들어 보자.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>myplugin.js:</b></p>
<pre id="code_1704771893642" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>class MyPlugin {
  apply (compiler) {
    compiler.plugin("emit", (compilation, callback) =&gt; {
      const source = compilation.assets['main.js'].source();
      compilation.assets['main.js'].source = () =&gt; {
        const banner = [
          '/**',
          ' * 이것은 BannerPlugin이 처리한 결과입니다.',
          ' * Build Date: 2019-10-10',
          '*/'
          ..
        ].join('\n');
        return banner + '\n' + source;
      }
      
      callback();
    })
  }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">번들 소스를 얻어오는 함수 source()를 재정의 했다. 배너 문자열과 기존 소스 코드를 합친 문자열을 반환하도록 말이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">빌드하고 결과물을 확인해 /dist/main.js 파일 상단에 설정한 문구가 들어가 있는 것을 확인할 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><b>6. 자주 사용하는 플러그인</b></h2>
<p data-ke-size="size16">개발하면서 플러그인을 직접 작성할 일은 거의 없었다. 웹팩에서 직접 제공하는 플러그인을 사용하거나 써드파티 라이브러리를 찾아 사용하는데 자주 사용하는 플러그인에 대해 알아보자.</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><b>6-1. BannerPlugin</b></h3>
<p data-ke-size="size16">MyPlugin과 비슷한 것이 <span style="color: #000000;"><u>BannerPlugin</u></span>이다. 결과물에 빌드 정보나 커밋 버전같은 걸 추가할 수 있다.</p>
<p data-ke-size="size16">내장 플러그인으로 따로 설치 할 필요가 없다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>webpack.config.js:</b></p>
<pre id="code_1704772030401" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>const webpack = require('webpack');

module.exports = {
  plugins: [
    new webpack.BannerPlugin({
      banner: '이것은 배너 입니다',
    })
  ]
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">생성자 함수에 전달하는 옵션 객체의 banner 속성에 문자열을 전달한다. 웹팩 컴파일 타임에 얻을 수 있는 정보, 가령 빌드 시간이나 커밋 정보를 전달하기 위해 함수로 전달할 수도 있다.</p>
<pre id="code_1704772087554" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>new wabpack.BannerPlugin({
  banner: () =&gt; `빌드 날짜: ${new date().toLocaleString()}`,
})</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">배너 정보가 많다면 별도 파일로 분리하자.</p>
<pre id="code_1704772114411" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>const banner = require('./banner.js')

new webpack.BannerPlugin(banner)</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">빌드 날짜 외에서 커밋 해쉬와 빌드한 유저 정보까지 추가해 보자.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>banner.js:</b></p>
<pre id="code_1704772232684" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>const webpack = require('webpack');
const childProcess = require('child_process');
// ...
plugins: [
  new webpack.BannerPlugin({
    banner: `
      Build Date: ${new Date().toLocaleString()}
      Commit Version: ${childProcess.execSync('git rev-parse --short HEAD')}
      Author: ${childProcess.execSync('git config user.name')}
    `
  })
]</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">빌드한 뒤 플러그인이 처리한 결과는 다음과 같다.</p>
<p data-ke-size="size16">&nbsp;</p>
